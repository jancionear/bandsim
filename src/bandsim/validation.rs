use std::collections::BTreeMap;

use crate::bandsim::chain::{Block, ShardLink, ShardUId, MAX_SHARD_BANDWIDTH, MIN_RECEIPT_SIZE};

use super::simulation::SimulationRun;

/// Validate that bandwidth grants generated by BandwidthScheduler are legal.
/// Checks that the incoming and outgoing limits of every shard stay under the MAX_SHARD_BANDWIDTH.
pub fn validate_grants(grants: &BTreeMap<ShardLink, usize>) {
    let mut total_outgoing: BTreeMap<ShardUId, usize> = BTreeMap::new();
    let mut total_incoming: BTreeMap<ShardUId, usize> = BTreeMap::new();

    for (link, grant) in grants {
        *total_outgoing.entry(link.from).or_insert(0) += grant;
        *total_incoming.entry(link.to).or_insert(0) += grant;
    }

    for (shard_id, outgoing) in total_outgoing {
        if outgoing > MAX_SHARD_BANDWIDTH {
            panic!("Total outgoing for shard {:?} is {}", shard_id, outgoing);
        }
    }
    for (shard_id, incoming) in total_incoming {
        if incoming > MAX_SHARD_BANDWIDTH {
            panic!("Total incoming for shard {:?} is {}", shard_id, incoming);
        }
    }
}

/// Validate that receipts sent in the block are legal.
/// A shard should receive at most MAX_SHARD_BANDWIDTH at every height.
/// The only exception is when the previous chunk was missing on a shard,
/// then the shard can receive 2 * MAX_SHARD_BANDWIDTH, but it can't be
/// more than that.
pub fn validate_block(block: &Block, prev_blocks: &[Option<Block>]) {
    let prev_block = prev_blocks.iter().rev().flatten().next();

    for (shard_id, chunk_opt) in &block.chunks {
        let Some(chunk) = chunk_opt else {
            continue;
        };

        let prev_chunk_missing = prev_block
            .map(|b: &Block| !b.chunks.get(shard_id).unwrap().is_some())
            .unwrap_or(false);

        let max_incoming_receipts = if prev_chunk_missing {
            2 * MAX_SHARD_BANDWIDTH
        } else {
            MAX_SHARD_BANDWIDTH
        };
        if chunk.prev_incoming_receipts_size > max_incoming_receipts {
            panic!(
                "TOO MANY INCOMING RECEIPTS! {} > {}",
                chunk.prev_incoming_receipts_size, max_incoming_receipts
            );
        }

        let total_outgoing_receipts: usize = chunk.prev_outgoing_receipts_size.values().sum();
        if total_outgoing_receipts > MAX_SHARD_BANDWIDTH {
            panic!(
                "TOO MANY OUTGOING RECEIPTS! {} > {}",
                total_outgoing_receipts, MAX_SHARD_BANDWIDTH
            );
        }

        for bandwidth_request in &chunk.bandwidth_requests {
            if bandwidth_request.grant_options_bitmap.is_all_false() {
                panic!("Bandwidth request has no options!");
            }
        }
    }
}

/// How much was sent between each pair of shards.
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct TotalSent {
    total_sent: BTreeMap<ShardLink, usize>,
    pub num_blocks: usize,
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct SentRatio {
    pub max_link: ShardLink,
    pub max_sent: usize,
    pub min_link: ShardLink,
    pub min_sent: usize,
    pub ratio: f64,
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
pub struct BandwidthUtilization {
    pub theoretical_throughput: usize,
    pub actual_throughput: usize,
    pub utilization: f64,
}

impl TotalSent {
    /// Gather information on how much was sent between each pair of shards in these blocks.
    pub fn new(simulation_run: &SimulationRun) -> TotalSent {
        let simulation = &simulation_run.simulation;

        let mut total_sent = BTreeMap::new();
        let mut num_blocks = 0;
        for block_opt in simulation.blocks.iter() {
            let Some(block) = block_opt else {
                continue;
            };
            num_blocks += 1;

            for (shard_id, chunk_opt) in &block.chunks {
                let Some(chunk) = chunk_opt else {
                    continue;
                };

                for (to_shard, sent) in &chunk.prev_outgoing_receipts_size {
                    let shard_link = ShardLink {
                        from: *shard_id,
                        to: *to_shard,
                    };
                    *total_sent.entry(shard_link).or_insert(0) += sent;
                }
            }
        }

        let has_receipt_sender = |shard_link: &ShardLink| {
            simulation
                .shards
                .get(&shard_link.from)
                .unwrap()
                .receipt_senders
                .contains_key(&shard_link.to)
        };

        // Remove results for links that didn't have any receipt senders, they mess up the metrics.
        let mut final_result: BTreeMap<ShardLink, usize> = BTreeMap::new();
        for (link, sent) in total_sent {
            if has_receipt_sender(&link) {
                final_result.insert(link, sent);
            } else {
                assert_eq!(sent, 0);
            }
        }

        TotalSent {
            total_sent: final_result,
            num_blocks,
        }
    }

    /// Calculate the ratio between the link that sent the most and the link that sent the least.
    /// This ratio should stay reasonable to keep things fair.
    /// It can't be exactly fair because large receipts can't be sent at the same throughput as the
    /// small ones, but it should stay below 2x.
    pub fn max_min_ratio(&self) -> SentRatio {
        assert!(!self.total_sent.is_empty());

        let mut max_link = None;
        let mut max_sent = 0;

        let mut min_link = None;
        let mut min_sent = usize::MAX;

        for (link, sent) in &self.total_sent {
            if *sent > max_sent {
                max_sent = *sent;
                max_link = Some(*link);
            }
            if *sent < min_sent {
                min_sent = *sent;
                min_link = Some(*link);
            }
        }

        if min_sent == 0 {
            panic!(
                "TotalSent - can't calculate max/min ratio, link {:?} had 0 bytes sent",
                min_link
            );
        }
        let ratio = max_sent as f64 / min_sent as f64;

        SentRatio {
            max_link: max_link.unwrap(),
            max_sent,
            min_link: min_link.unwrap(),
            min_sent,
            ratio,
        }
    }

    /// Calculate the ratio between the theoretic throughput when small receipts are sent on all links
    /// and the actual number of bytes that was sent during the test.
    /// The real utilization should be at least 50% of the theoretic one (real can be lower because of
    /// large receipts).
    pub fn bandwidth_utilization(&self) -> BandwidthUtilization {
        let theoretical_throughput = estimate_total_throughput(self.total_sent.keys());
        let actual_throughput = self.total_sent.values().sum::<usize>() / self.num_blocks;

        BandwidthUtilization {
            theoretical_throughput,
            actual_throughput,
            utilization: actual_throughput as f64 / theoretical_throughput as f64,
        }
    }
}

/// Estimate the total throughput that can be sent over the provided links in a single block.
/// The function simulates a scenario where small receipts are sent as fast as possible
/// on all links.
/// Every link is equally important, so the function grants some bandwidth
/// on every link as long as senders/receivers have more bandwidth to spare.
pub fn estimate_total_throughput<'a, LinksIter: Iterator<Item = &'a ShardLink> + Clone>(
    active_links: LinksIter,
) -> usize {
    let mut outgoing_limits = BTreeMap::new();
    let mut incoming_limits = BTreeMap::new();

    for link in active_links.clone() {
        outgoing_limits.insert(link.from, MAX_SHARD_BANDWIDTH);
        incoming_limits.insert(link.to, MAX_SHARD_BANDWIDTH);
    }

    let mut total = 0;
    let grant_size = MIN_RECEIPT_SIZE;
    loop {
        let mut granted_some = false;
        for link in active_links.clone() {
            let outgoing_limit = outgoing_limits.get_mut(&link.from).unwrap();
            let incoming_limit = incoming_limits.get_mut(&link.to).unwrap();
            if *incoming_limit >= grant_size && *outgoing_limit >= grant_size {
                total += grant_size;
                *outgoing_limit -= grant_size;
                *incoming_limit -= grant_size;
                granted_some = true;
            }
        }
        if !granted_some {
            break;
        }
    }

    total
}

pub struct TestStats {
    pub total_sent: TotalSent,
    pub max_min_ratio: SentRatio,
    pub bandwidth_utilization: BandwidthUtilization,
    pub missing_chunks_ratio: f64,
}

impl TestStats {
    pub fn new(simulation_run: &SimulationRun) -> TestStats {
        let total_sent = TotalSent::new(simulation_run);

        println!("Total sent:\n{:#?}", total_sent.total_sent);

        let max_min_ratio = total_sent.max_min_ratio();
        let bandwidth_utilization = total_sent.bandwidth_utilization();

        let mut missing_chunks = 0;
        let mut all_chunks = 0;
        for block in simulation_run.simulation.blocks.iter().flatten() {
            for chunk_opt in block.chunks.values() {
                all_chunks += 1;
                if !chunk_opt.is_some() {
                    missing_chunks += 1;
                }
            }
        }
        let missing_chunks_ratio = missing_chunks as f64 / all_chunks as f64;

        println!("{:#?}", max_min_ratio);
        println!("{:#?}", bandwidth_utilization);

        println!("\n=== Main metrics: ======================================================");
        println!(
            "  max sent/min sent ratio (fairness) = {:.2}% (the smaller the better)",
            max_min_ratio.ratio * 100.0
        );
        println!(
            "  bandwidth utilization = {:.2}% (the bigger the better)",
            bandwidth_utilization.utilization * 100.0
        );
        println!(
            "  missing chunk ratio: {:.2}%",
            missing_chunks_ratio * 100.0
        );
        println!("========================================================================");

        TestStats {
            total_sent,
            max_min_ratio,
            bandwidth_utilization,
            missing_chunks_ratio,
        }
    }

    /// Basic assertion that should be true for all tests
    pub fn basic_assert(&self) {
        assert!(self.max_min_ratio.ratio <= 2.15);
        assert!(self.bandwidth_utilization.utilization > 0.49);
    }
}
