use rand::Rng;
use rand_distr::{Distribution, Weibull};

use crate::bandsim::chain::{Receipt, MAX_RECEIPT_SIZE, MIN_RECEIPT_SIZE};
use crate::bandsim::rng::DefaultRng;

use super::outgoing_queue::OutgoingQueue;

/// Sends any number of receipts to the provided queue
pub trait ReceiptSender: std::fmt::Debug {
    fn send_receipts(&mut self, outgoing_queue: &mut OutgoingQueue, rng: &mut DefaultRng);
}

/// Generates a single receipt of some kind
pub trait ReceiptGenerator: std::fmt::Debug {
    fn generate_receipt(&mut self, rng: &mut DefaultRng) -> Receipt;
}

/// Sends receipts of some kind as fast as possible.
#[derive(Debug)]
pub struct FullSpeedReceiptSender<RG: ReceiptGenerator>(pub RG);

impl<RG: ReceiptGenerator> ReceiptSender for FullSpeedReceiptSender<RG> {
    fn send_receipts(&mut self, outgoing_queue: &mut OutgoingQueue, rng: &mut DefaultRng) {
        while outgoing_queue.total_size() < 10_000_000 {
            let receipt = self.0.generate_receipt(rng);
            outgoing_queue.push(receipt);
        }
    }
}

/// Doesn't send any receipts
#[derive(Debug)]
pub struct NoReceiptSender;

impl ReceiptSender for NoReceiptSender {
    fn send_receipts(&mut self, _outgoing_queue: &mut OutgoingQueue, _rng: &mut DefaultRng) {
        // Doesn't send any receipts
    }
}

/// Always generates receipts of one size
#[derive(Debug)]
pub struct OneSizeReceiptGenerator {
    pub size: usize,
}

impl ReceiptGenerator for OneSizeReceiptGenerator {
    fn generate_receipt(&mut self, _rng: &mut DefaultRng) -> Receipt {
        Receipt { size: self.size }
    }
}

/// Generates receipts of random sizes, receipt sizes are sampled from a uniform distribution
#[derive(Debug)]
pub struct RandomSizeReceiptGenerator {
    pub size_range: std::ops::RangeInclusive<usize>,
}

impl ReceiptGenerator for RandomSizeReceiptGenerator {
    fn generate_receipt(&mut self, rng: &mut DefaultRng) -> Receipt {
        Receipt {
            size: rng.gen_range(self.size_range.clone()),
        }
    }
}

/// Generates receipts of the "typical" size - mostly small, sometimes big.
// TODO - Make sure that receipts generated by this match the real world.
#[derive(Debug)]
pub struct TypicalReceiptGenerator {
    distribution: Weibull<f64>,
}

impl TypicalReceiptGenerator {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TypicalReceiptGenerator {
        TypicalReceiptGenerator {
            distribution: Weibull::new(0.1, 1.0).unwrap(),
        }
    }
}

impl ReceiptGenerator for TypicalReceiptGenerator {
    fn generate_receipt(&mut self, rng: &mut DefaultRng) -> Receipt {
        let sample: f64 = self.distribution.sample(rng);
        let receipt_size: usize = ((MAX_RECEIPT_SIZE - MIN_RECEIPT_SIZE) as f64 * sample) as usize;
        if !(MIN_RECEIPT_SIZE..=MAX_RECEIPT_SIZE).contains(&receipt_size) {
            return self.generate_receipt(rng);
        }
        Receipt { size: receipt_size }
    }
}

/// Visualise the histogram of receipt sizes generated by a receipt generator.
pub mod tests {
    use crate::bandsim::chain::MAX_RECEIPT_SIZE;

    use super::{ReceiptGenerator, TypicalReceiptGenerator};

    fn show_generated_size_distribution(generator: &mut impl ReceiptGenerator) {
        use crate::bandsim::rng::rng_from_seed;

        let samples = 100000;
        let bucket_size = 80_000;

        let mut next_bucket_start = 0;
        let mut buckets = Vec::new();
        loop {
            let mut bucket_end = next_bucket_start + bucket_size;
            if bucket_end > MAX_RECEIPT_SIZE {
                bucket_end = MAX_RECEIPT_SIZE;
            }
            buckets.push((next_bucket_start..=bucket_end, 0));
            next_bucket_start = bucket_end;
            if next_bucket_start == MAX_RECEIPT_SIZE {
                break;
            }
        }

        let mut min = usize::MAX;
        let mut max = 0;
        let mut rng = rng_from_seed(0);
        for _ in 0..samples {
            let receipt = generator.generate_receipt(&mut rng);
            if receipt.size > MAX_RECEIPT_SIZE {
                panic!(
                    "receipt size too large! {} > {}",
                    receipt.size, MAX_RECEIPT_SIZE
                );
            }
            for (range, count) in buckets.iter_mut() {
                if range.contains(&receipt.size) {
                    *count += 1;
                }
            }
            if receipt.size < min {
                min = receipt.size;
            }
            if receipt.size > max {
                max = receipt.size;
            }
        }

        let max_count = buckets.iter().map(|(_, count)| count).max().unwrap();
        let max_histogram_bar_len = 140;

        let aligned_number = |num: usize| {
            let target_len = 8;
            let mut num_str = num.to_string();
            while num_str.len() < target_len {
                num_str = " ".to_string() + &num_str;
            }
            num_str
        };

        println!("Generator: {:?}", generator);
        println!("{} samples, min = {}, max = {}", samples, min, max);
        for (range, count) in &buckets {
            let bar_len =
                ((*count as f64 / *max_count as f64) * max_histogram_bar_len as f64) as usize;
            let mut bar: String = "#".repeat(bar_len);
            if bar.is_empty() && *count > 0 {
                bar.push('.');
            }

            println!("{}: {}", aligned_number(*range.end()), bar);
        }
    }

    /// Run with `--nocapture` to see the histogram
    /// cargo test --release show_typical_generator -- --nocapture
    #[test]
    fn show_typical_generator_size_distribution() {
        show_generated_size_distribution(&mut TypicalReceiptGenerator::new());
    }
}
